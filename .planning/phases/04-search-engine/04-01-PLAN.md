---
phase: 04-search-engine
plan: 01
type: execute
---

<objective>
Implement PostgreSQL full-text search with SearchVectorField, automatic trigger updates, and filter support.

Purpose: Enable users to search jokes by keywords with relevance ranking, combined with metadata filters (format, age rating, tones, context).
Output: Working search infrastructure on Joke model with GIN-indexed SearchVectorField and reusable JokeManager.search() method.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-search-engine/04-RESEARCH.md
@.planning/phases/02-data-models/02-01-SUMMARY.md

# Key source files:
@jokes/models.py

**Tech stack available:**
- Django 5.x with django.contrib.postgres
- PostgreSQL with psycopg2-binary
- 8 models with FK/M2M relationships (from Phase 02)
- 137 seeded jokes (from Phase 03)

**Established patterns:**
- Lookup tables with slug fields for URL-friendly filtering
- M2M for multi-value attributes (tones, context_tags)
- FK for single-value attributes (format, age_rating)

**From RESEARCH.md - Don't hand-roll:**
- Search indexing → use SearchVectorField + django-pgtrigger trigger
- Trigger management → use django-pgtrigger (not raw SQL)
- Typo tolerance → use TrigramSimilarity + pg_trgm (not custom fuzzy matching)
- Result ranking → use SearchRank (not custom scoring)

**From RESEARCH.md - Pitfalls to avoid:**
- DON'T compute tsvector on-the-fly (use pre-computed SearchVectorField)
- DON'T skip GIN index (required for performance)
- DON'T forget to handle empty search queries
- DO use search_type='websearch' for user queries
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SearchVectorField with trigger and GIN index</name>
  <files>requirements.txt, jokes/models.py, jokes/migrations/0002_*.py, jokes/migrations/0003_*.py</files>
  <action>
1. Add django-pgtrigger to requirements.txt and install:
   ```
   django-pgtrigger==4.17.0
   ```
   Run: pip install -r requirements.txt

2. Add 'pgtrigger' to INSTALLED_APPS in settings.py

3. Create migration for pg_trgm extension (for future trigram support):
   - Create new migration file
   - Add TrigramExtension() operation
   - This enables TrigramSimilarity for typo tolerance later

4. Update jokes/models.py - add to Joke model:
   ```python
   from django.contrib.postgres.search import SearchVectorField
   from django.contrib.postgres.indexes import GinIndex
   import pgtrigger

   # Add field to Joke class:
   search_vector = SearchVectorField(null=True, blank=True)

   # Update Meta class:
   class Meta:
       ordering = ['-created_at']
       indexes = [
           GinIndex(fields=['search_vector'], name='joke_search_vector_idx'),
       ]
       triggers = [
           pgtrigger.UpdateSearchVector(
               name='joke_search_vector_update',
               vector_field='search_vector',
               document_fields=['text', 'setup', 'punchline'],
           )
       ]
   ```

5. Generate and apply migrations:
   - python manage.py makemigrations jokes
   - python manage.py migrate

AVOID: Don't use on_delete or any relationship-related parameters on SearchVectorField - it's not a FK.
AVOID: Don't create triggers manually with RunSQL - use pgtrigger.UpdateSearchVector.
  </action>
  <verify>
- python manage.py check passes
- python manage.py showmigrations shows all migrations applied
- psql -d jokesfor -c "\d jokes_joke" shows search_vector column
- psql -d jokesfor -c "\di" shows joke_search_vector_idx GIN index
  </verify>
  <done>
- django-pgtrigger installed and in INSTALLED_APPS
- pg_trgm extension enabled
- SearchVectorField added to Joke model
- GIN index created on search_vector
- UpdateSearchVector trigger configured
- All migrations applied successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JokeManager with search method</name>
  <files>jokes/managers.py, jokes/models.py</files>
  <action>
1. Create jokes/managers.py with JokeManager class:
   ```python
   from django.db import models
   from django.contrib.postgres.search import SearchQuery, SearchRank

   class JokeManager(models.Manager):
       def search(self, query_text=None, filters=None):
           """
           Full-text search with optional filters.

           Args:
               query_text: Search string (optional - if empty, returns all)
               filters: Dict with optional keys:
                   - format: slug string
                   - age_rating: slug string
                   - tones: list of slug strings
                   - context_tags: list of slug strings
                   - culture_tags: list of slug strings
                   - language: code string

           Returns:
               QuerySet ordered by relevance (if searching) or date (if browsing)
           """
           qs = self.get_queryset()

           # Full-text search
           if query_text and query_text.strip():
               query = SearchQuery(query_text.strip(), search_type='websearch')
               qs = qs.annotate(
                   rank=SearchRank('search_vector', query)
               ).filter(search_vector=query)

           # Apply filters
           if filters:
               if filters.get('format'):
                   qs = qs.filter(format__slug=filters['format'])
               if filters.get('age_rating'):
                   qs = qs.filter(age_rating__slug=filters['age_rating'])
               if filters.get('tones'):
                   qs = qs.filter(tones__slug__in=filters['tones'])
               if filters.get('context_tags'):
                   qs = qs.filter(context_tags__slug__in=filters['context_tags'])
               if filters.get('culture_tags'):
                   qs = qs.filter(culture_tags__slug__in=filters['culture_tags'])
               if filters.get('language'):
                   qs = qs.filter(language__code=filters['language'])

           # Order by rank if searching, else by date
           if query_text and query_text.strip():
               qs = qs.order_by('-rank')
           else:
               qs = qs.order_by('-created_at')

           return qs.distinct()
   ```

2. Update jokes/models.py - add manager to Joke model:
   ```python
   from .managers import JokeManager

   class Joke(models.Model):
       # ... existing fields ...

       # Add manager
       objects = JokeManager()
   ```

AVOID: Don't use search_type='plain' - use 'websearch' for boolean operator support.
AVOID: Don't forget .distinct() - M2M filters can cause duplicates.
AVOID: Don't crash on empty query - handle None and empty string gracefully.
  </action>
  <verify>
- python manage.py check passes
- python manage.py shell:
  ```python
  from jokes.models import Joke
  # Should not error
  Joke.objects.search()
  Joke.objects.search('')
  Joke.objects.search(None)
  ```
  </verify>
  <done>
- JokeManager created in jokes/managers.py
- Manager wired to Joke model
- search() method handles empty queries gracefully
- search() method supports all filter dimensions
- No errors on basic manager operations
  </done>
</task>

<task type="auto">
  <name>Task 3: Backfill search vectors and verify functionality</name>
  <files>None (shell commands only)</files>
  <action>
1. Backfill search vectors for existing 137 jokes.
   The trigger only fires on INSERT/UPDATE, so existing rows need manual update.

   Run in Django shell:
   ```python
   from jokes.models import Joke
   from django.contrib.postgres.search import SearchVector

   # Update all jokes to trigger the search vector population
   # The trigger will compute the vector on update
   for joke in Joke.objects.all():
       joke.save()

   # Verify vectors are populated
   populated = Joke.objects.exclude(search_vector=None).count()
   total = Joke.objects.count()
   print(f"Search vectors populated: {populated}/{total}")
   ```

2. Test full-text search:
   ```python
   from jokes.models import Joke

   # Test basic search
   results = Joke.objects.search('chicken')
   print(f"Found {results.count()} jokes about chicken")

   # Test with filter
   results = Joke.objects.search('why', filters={'format': 'one-liner'})
   print(f"Found {results.count()} one-liner jokes with 'why'")

   # Test empty search (should return all, ordered by date)
   all_jokes = Joke.objects.search()
   print(f"Browse mode: {all_jokes.count()} jokes")

   # Test filter only (no search term)
   clean_jokes = Joke.objects.search(filters={'tones': ['clean']})
   print(f"Clean jokes: {clean_jokes.count()}")
   ```

3. Verify ranking works:
   ```python
   results = Joke.objects.search('doctor')
   for joke in results[:3]:
       print(f"Rank: {joke.rank:.3f} - {joke.text[:50]}...")
   ```

AVOID: Don't use bulk_update - it bypasses triggers. Use individual save() calls.
  </action>
  <verify>
- All 137 jokes have populated search_vector (not NULL)
- Search for common words returns results
- Filter combinations work correctly
- Ranking is present on search results
- Empty search returns all jokes ordered by date
  </verify>
  <done>
- All existing jokes have search vectors populated
- Full-text search returns relevant results
- Filters narrow results correctly
- SearchRank ordering works
- Phase 04 search infrastructure complete
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] python manage.py check passes
- [ ] All migrations applied (python manage.py showmigrations)
- [ ] Search vectors populated for all jokes
- [ ] Joke.objects.search('keyword') returns ranked results
- [ ] Joke.objects.search(filters={'format': 'one-liner'}) filters correctly
- [ ] Empty search returns all jokes ordered by date
- [ ] No N+1 queries in search (single query with filters)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- SearchVectorField + GIN index configured
- django-pgtrigger UpdateSearchVector trigger active
- JokeManager.search() method supports full-text + filters
- Existing jokes have search vectors populated
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-engine/04-01-SUMMARY.md` using summary template with:
- Frontmatter: phase, plan, subsystem (search), tags, requires/provides/affects, tech-stack, key-files, key-decisions
- Performance metrics
- Accomplishments (SearchVectorField, GIN index, trigger, manager)
- Task commits
- Files created/modified
- Decisions made
- Next phase readiness (ready for Phase 05: API Core)
</output>
