---
phase: 08-collections
plan: 01
type: execute
---

<objective>
Create Collection and SavedJoke models for personal joke library and collections feature.

Purpose: Enable users to save jokes and organize them into custom collections (folders).
Output: Two Django models with migrations, admin interface, and auto-created "Favorites" collection.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/07-user-preferences/07-01-SUMMARY.md (signal pattern for auto-creation)
@.planning/phases/06-authentication/06-03-SUMMARY.md (user model, auth)

# Key files:
@jokes/models.py (existing models, UserPreference pattern)
@jokes/signals.py (signal pattern reference)
@jokes/admin.py (admin registration patterns)

**Tech stack available:** Django 5.x, DRF, PostgreSQL
**Established patterns:**
- settings.AUTH_USER_MODEL for user FK references
- post_save signal for auto-creation of user-related records
- PROTECT on_delete for required FKs, CASCADE for user-owned data
- Admin with list_display, list_filter, search_fields
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Collection and SavedJoke models</name>
  <files>jokes/models.py</files>
  <action>
Add two models after UserPreference:

**Collection model:**
- user: FK to settings.AUTH_USER_MODEL, CASCADE on delete (user owns collections)
- name: CharField max_length=100
- description: TextField blank=True
- is_default: BooleanField default=False (for "Favorites" collection)
- created_at: DateTimeField auto_now_add
- updated_at: DateTimeField auto_now
- class Meta: ordering = ['-is_default', 'name'], unique_together = [['user', 'name']]
- __str__: return f"{self.name} ({self.user.email})"

**SavedJoke model:**
- user: FK to settings.AUTH_USER_MODEL, CASCADE on delete
- joke: FK to Joke, CASCADE on delete (if joke deleted, remove saved)
- collection: FK to Collection, CASCADE on delete, null=True blank=True (can save without collection)
- note: TextField blank=True (optional user note)
- created_at: DateTimeField auto_now_add
- class Meta: ordering = ['-created_at'], unique_together = [['user', 'joke', 'collection']]
- __str__: return f"{self.user.email} saved joke {self.joke_id}"

Use CASCADE for user FK because user owns these records. Use CASCADE for joke FK because a deleted joke shouldn't remain "saved".
  </action>
  <verify>python manage.py check --fail-level WARNING returns no errors</verify>
  <done>Collection and SavedJoke models defined with proper FKs, Meta options, and __str__ methods</done>
</task>

<task type="auto">
  <name>Task 2: Create migrations and update signals</name>
  <files>jokes/migrations/*.py, jokes/signals.py</files>
  <action>
1. Run: python manage.py makemigrations jokes
2. Run: python manage.py migrate

3. Update jokes/signals.py to auto-create default "Favorites" collection for new users:
   - Import Collection model
   - In create_user_preference signal OR create new signal:
     - After UserPreference creation, also create Collection with name="Favorites", is_default=True
   - Alternative: Add Collection.objects.get_or_create in same signal function

Keep it simple - add to existing user_created signal if possible.
  </action>
  <verify>python manage.py migrate shows migration applied. Manual check: Create test user via shell, verify Favorites collection exists.</verify>
  <done>Migration applied, new users automatically get "Favorites" collection</done>
</task>

<task type="auto">
  <name>Task 3: Configure admin interface</name>
  <files>jokes/admin.py</files>
  <action>
Add admin classes for Collection and SavedJoke:

**CollectionAdmin:**
- list_display: ['name', 'user', 'is_default', 'created_at']
- list_filter: ['is_default', 'created_at']
- search_fields: ['name', 'user__email']
- readonly_fields: ['created_at', 'updated_at']

**SavedJokeAdmin:**
- list_display: ['user', 'joke', 'collection', 'created_at']
- list_filter: ['created_at', 'collection']
- search_fields: ['user__email', 'joke__text']
- readonly_fields: ['created_at']
- raw_id_fields: ['joke'] (for better performance with many jokes)

Register both with admin.site.register().
  </action>
  <verify>python manage.py runserver starts, admin at /admin/ shows Collection and SavedJoke models</verify>
  <done>Admin interface configured with filters, search, and appropriate display fields</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python manage.py check` passes
- [ ] `python manage.py migrate` shows no pending migrations
- [ ] Collection model has user FK, name, is_default, timestamps
- [ ] SavedJoke model has user FK, joke FK, collection FK, note, timestamp
- [ ] New user creation triggers Favorites collection creation
- [ ] Admin shows both models with proper display/filters
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No Django warnings or errors
- Models follow established project patterns
- Auto-creation signal works for Favorites collection
</success_criteria>

<output>
After completion, create `.planning/phases/08-collections/08-01-SUMMARY.md` with:
- Models created and their fields
- Signal behavior for auto-creation
- Admin configuration
- Migration file name
- Any deviations from plan
</output>
