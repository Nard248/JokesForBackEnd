---
phase: 08-collections
plan: 02
type: execute
---

<objective>
Create API endpoints for collection management and saving jokes.

Purpose: Expose collection CRUD operations and save/unsave joke functionality via REST API.
Output: CollectionViewSet with full CRUD, SavedJokeViewSet with add/remove, URL routes.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/08-collections/08-01-SUMMARY.md (Collection and SavedJoke models)
@.planning/phases/07-user-preferences/07-02-SUMMARY.md (ViewSet patterns, serializer patterns)
@.planning/phases/05-api-core/05-02-SUMMARY.md (router registration, viewset patterns)

# Key files:
@jokes/models.py (Collection, SavedJoke models)
@jokes/serializers.py (existing serializer patterns)
@jokes/views.py (existing viewset patterns)
@jokes/urls.py (router registration pattern)

**Tech stack available:** Django 5.x, DRF 3.16, drf-spectacular
**Established patterns:**
- ModelViewSet for full CRUD
- GenericViewSet for custom actions only
- Nested serializers for read, PrimaryKeyRelatedField for write
- @action decorator for custom endpoints
- DefaultRouter for URL generation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Collection and SavedJoke serializers</name>
  <files>jokes/serializers.py</files>
  <action>
Add serializers after UserPreference serializers:

**CollectionSerializer (read):**
- Fields: id, name, description, is_default, joke_count, created_at, updated_at
- joke_count: SerializerMethodField that returns collection.savedjoke_set.count()
- read_only_fields: ['id', 'is_default', 'created_at', 'updated_at'] (is_default managed by system)

**CollectionCreateSerializer (write):**
- Fields: name, description
- Validate name uniqueness per user in validate_name method

**SavedJokeSerializer (read):**
- Fields: id, joke, collection, note, created_at
- joke: Nested JokeListSerializer (compact view)
- collection: Nested CollectionSerializer or just id/name

**SavedJokeCreateSerializer (write):**
- Fields: joke, collection, note
- joke: PrimaryKeyRelatedField to Joke queryset
- collection: PrimaryKeyRelatedField to Collection queryset, allow_null=True
- Validate: collection belongs to current user (via context['request'].user)
- Validate: joke not already saved by user in same collection

Import Collection and SavedJoke in model imports at top.
  </action>
  <verify>python manage.py check passes, no import errors</verify>
  <done>Four serializers created: CollectionSerializer, CollectionCreateSerializer, SavedJokeSerializer, SavedJokeCreateSerializer</done>
</task>

<task type="auto">
  <name>Task 2: Create Collection and SavedJoke ViewSets</name>
  <files>jokes/views.py</files>
  <action>
Add two viewsets after UserPreferenceViewSet:

**CollectionViewSet (ModelViewSet):**
- permission_classes: [IsAuthenticated]
- get_queryset: return Collection.objects.filter(user=request.user)
- get_serializer_class: CollectionCreateSerializer for create/update, CollectionSerializer otherwise
- perform_create: set collection.user = request.user
- Custom action: @action(detail=True, methods=['get']) jokes() - list jokes in collection
  - Return paginated SavedJoke queryset filtered by collection
  - Use SavedJokeSerializer

**SavedJokeViewSet (mixins.CreateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):**
- Only create (save), delete (unsave), and list
- permission_classes: [IsAuthenticated]
- get_queryset: return SavedJoke.objects.filter(user=request.user).select_related('joke', 'collection')
- get_serializer_class: SavedJokeCreateSerializer for create, SavedJokeSerializer otherwise
- perform_create: set savedjoke.user = request.user
- Custom action: @action(detail=False, methods=['get']) search() - search within saved jokes
  - Accept q param for text search
  - Filter SavedJoke by user, then filter related joke using Joke.objects.search()

Import Collection, SavedJoke in model imports.
Import mixins from rest_framework.
Add extend_schema decorators for OpenAPI docs.
  </action>
  <verify>python manage.py check passes</verify>
  <done>CollectionViewSet with CRUD + jokes action, SavedJokeViewSet with create/delete/list + search</done>
</task>

<task type="auto">
  <name>Task 3: Register routes and verify endpoints</name>
  <files>jokes/urls.py</files>
  <action>
Register viewsets with router:

router.register('collections', views.CollectionViewSet, basename='collection')
router.register('saved-jokes', views.SavedJokeViewSet, basename='saved-joke')

Then verify all endpoints work via curl or httpie:
- GET /api/v1/collections/ - list user's collections
- POST /api/v1/collections/ - create collection
- GET /api/v1/collections/{id}/ - get collection
- PATCH /api/v1/collections/{id}/ - update collection
- DELETE /api/v1/collections/{id}/ - delete collection (except is_default)
- GET /api/v1/collections/{id}/jokes/ - list jokes in collection
- GET /api/v1/saved-jokes/ - list all saved jokes
- POST /api/v1/saved-jokes/ - save a joke
- DELETE /api/v1/saved-jokes/{id}/ - unsave a joke
- GET /api/v1/saved-jokes/search/?q=... - search saved jokes
  </action>
  <verify>python manage.py runserver starts. curl -X GET http://localhost:8000/api/v1/collections/ with auth returns 200 or 401 (auth required). /api/docs/ shows new endpoints.</verify>
  <done>Routes registered, all endpoints accessible, OpenAPI docs updated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python manage.py check` passes
- [ ] Collection CRUD endpoints work (list, create, retrieve, update, delete)
- [ ] Collection jokes listing works (/collections/{id}/jokes/)
- [ ] SavedJoke create/delete/list work
- [ ] SavedJoke search within saved jokes works
- [ ] Swagger docs at /api/docs/ show all new endpoints
- [ ] Authentication required for all endpoints (401 when not authenticated)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No Django warnings or errors
- API follows established project patterns
- OpenAPI documentation accurate
- Phase 08: Collections complete
</success_criteria>

<output>
After completion, create `.planning/phases/08-collections/08-02-SUMMARY.md` with:
- Serializers created
- ViewSets and their actions
- URL routes registered
- Any validation logic implemented
- Any deviations from plan
- "Phase 08: Collections COMPLETE"
</output>
