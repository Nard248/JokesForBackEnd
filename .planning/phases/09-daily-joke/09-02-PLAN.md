---
phase: 09-daily-joke
plan: 02
type: execute
---

<objective>
Create DailyJoke model and content-based recommendation algorithm.

Purpose: Enable personalized daily joke selection based on user preferences, avoiding recently shown jokes.
Output: DailyJoke model with migration, recommendation algorithm in jokes/recommendations.py.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-daily-joke/09-RESEARCH.md
@.planning/phases/09-daily-joke/09-01-SUMMARY.md

**Key files:**
@jokes/models.py
@jokes/managers.py

**Tech stack available:**
- Django 5.2.10 + DRF
- PostgreSQL with full-text search
- UserPreference model with preferred_tones, preferred_contexts, preferred_age_rating, preferred_language
- Celery infrastructure (from 09-01)

**Constraining decisions:**
- RESEARCH.md: Use content-based filtering for MVP (not collaborative filtering)
- RESEARCH.md: DON'T hand-roll recommendation ranking (use preference scoring + popularity)
- RESEARCH.md: Track 30-day recency window to avoid joke exhaustion
- STATE.md: CASCADE on_delete for user-owned data

**Patterns established:**
- settings.AUTH_USER_MODEL for user FKs
- CASCADE on_delete for user-owned models
- related_name for reverse lookups
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DailyJoke model</name>
  <files>jokes/models.py, jokes/admin.py</files>
  <action>
Add DailyJoke model to jokes/models.py:

```python
class DailyJoke(models.Model):
    """Track daily joke delivered to each user"""
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='daily_jokes'
    )
    joke = models.ForeignKey(
        'Joke',
        on_delete=models.CASCADE,
        related_name='daily_deliveries'
    )
    date = models.DateField()
    delivered_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = [['user', 'date']]
        ordering = ['-date']
        indexes = [
            models.Index(fields=['user', 'date']),
        ]

    def __str__(self):
        return f"Daily joke for {self.user.email} on {self.date}"
```

Add DailyJokeAdmin to jokes/admin.py:
- list_display: ['user', 'joke', 'date', 'delivered_at']
- list_filter: ['date', 'delivered_at']
- search_fields: ['user__email']
- date_hierarchy: 'date'
- raw_id_fields: ['user', 'joke'] (for performance with many records)

Run: python manage.py makemigrations jokes
Run: python manage.py migrate
  </action>
  <verify>python manage.py check passes, python manage.py showmigrations jokes shows new migration applied</verify>
  <done>DailyJoke model created with unique_together constraint, admin registered, migration applied</done>
</task>

<task type="auto">
  <name>Task 2: Create content-based recommendation algorithm</name>
  <files>jokes/recommendations.py</files>
  <action>
Create jokes/recommendations.py with content-based filtering:

```python
from django.db.models import Count, Q
from django.utils import timezone
from datetime import timedelta

from .models import Joke, DailyJoke


def get_recently_shown_joke_ids(user, days=30):
    """
    Get joke IDs shown to user in the last N days.
    Uses recency window to prevent exhaustion of small dataset.
    """
    cutoff_date = timezone.now().date() - timedelta(days=days)
    return list(
        DailyJoke.objects.filter(
            user=user,
            date__gte=cutoff_date
        ).values_list('joke_id', flat=True)
    )


def get_personalized_joke(user, exclude_joke_ids=None):
    """
    Content-based filtering using UserPreference.
    Returns a joke matching user's preferences, avoiding recently shown.

    Algorithm:
    1. Build filter from user preferences (tones, contexts, age_rating, language)
    2. Exclude recently shown jokes (30-day window)
    3. Order by popularity (save count) with randomness for variety
    4. Fallback to any joke if preferences too restrictive
    """
    try:
        prefs = user.preference
    except AttributeError:
        # User has no preference record (shouldn't happen with signal, but defensive)
        prefs = None

    exclude_ids = exclude_joke_ids or []

    # Start with all jokes, excluding recently shown
    base_queryset = Joke.objects.exclude(id__in=exclude_ids)

    if not base_queryset.exists():
        # All jokes exhausted - return None (caller should handle reset)
        return None

    # Build preference-based filter
    if prefs:
        filters = Q()

        if prefs.preferred_tones.exists():
            filters &= Q(tones__in=prefs.preferred_tones.all())

        if prefs.preferred_contexts.exists():
            filters &= Q(context_tags__in=prefs.preferred_contexts.all())

        if prefs.preferred_age_rating:
            filters &= Q(age_rating=prefs.preferred_age_rating)

        if prefs.preferred_language:
            filters &= Q(language=prefs.preferred_language)

        # Apply preference filter if any preferences set
        if filters:
            preference_matches = base_queryset.filter(filters).distinct()
            if preference_matches.exists():
                base_queryset = preference_matches
            # If no preference matches, fall back to base_queryset (any joke)

    # Order by popularity (save count) with randomness
    # This balances quality (popular jokes) with variety (randomness)
    return base_queryset.annotate(
        save_count=Count('saved_by')
    ).order_by('-save_count', '?').first()
```

Key design decisions:
- 30-day recency window prevents joke exhaustion with small dataset
- Preference matching is additive (AND) - finds jokes matching ALL preferences
- Fallback to any joke if preferences too restrictive
- Popularity scoring uses save_count from SavedJoke model
- Randomness ('?') adds variety within popularity tiers
  </action>
  <verify>python -c "from jokes.recommendations import get_personalized_joke; print('OK')" succeeds</verify>
  <done>recommendations.py created with get_personalized_joke and get_recently_shown_joke_ids functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python manage.py check` passes with no errors
- [ ] `python manage.py showmigrations jokes` shows DailyJoke migration applied
- [ ] `python -c "from jokes.models import DailyJoke; print(DailyJoke._meta.unique_together)"` shows user/date constraint
- [ ] `python -c "from jokes.recommendations import get_personalized_joke, get_recently_shown_joke_ids; print('OK')"` succeeds
- [ ] Admin interface shows DailyJoke with list_display, filters, search
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- DailyJoke model ready for Celery task
- Recommendation algorithm ready for use
- No Django errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/09-daily-joke/09-02-SUMMARY.md`
</output>
