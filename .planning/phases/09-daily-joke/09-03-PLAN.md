---
phase: 09-daily-joke
plan: 03
type: execute
---

<objective>
Create Celery task for daily joke generation and API endpoint for retrieving daily joke.

Purpose: Enable scheduled daily joke pre-generation and provide API for frontend to fetch today's joke.
Output: Working Celery task, DailyJoke API endpoint, phase complete.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-daily-joke/09-RESEARCH.md
@.planning/phases/09-daily-joke/09-01-SUMMARY.md
@.planning/phases/09-daily-joke/09-02-SUMMARY.md

**Key files:**
@jokes/models.py
@jokes/recommendations.py
@jokes/views.py
@jokes/urls.py

**Tech stack available:**
- Django 5.2.10 + DRF
- Celery + django-celery-beat (from 09-01)
- DailyJoke model + recommendations.py (from 09-02)
- JokeSerializer from Phase 05

**Constraining decisions:**
- RESEARCH.md: Pre-generate jokes at night, don't compute on-demand for every request
- RESEARCH.md: Provide on-demand fallback if scheduled task missed
- RESEARCH.md: DON'T hand-roll task scheduling (use Celery shared_task)
- STATE.md: Use /api/v1/ URL path versioning

**Patterns established:**
- @shared_task decorator for Celery tasks
- ViewSet with @action for custom endpoints
- IsAuthenticated permission for user-specific data
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Celery task for daily joke generation</name>
  <files>jokes/tasks.py</files>
  <action>
Create jokes/tasks.py with daily joke generation task:

```python
from celery import shared_task
from django.utils import timezone
from django.contrib.auth import get_user_model

from .models import DailyJoke
from .recommendations import get_personalized_joke, get_recently_shown_joke_ids


@shared_task(name='jokes.generate_daily_jokes')
def generate_daily_jokes():
    """
    Generate personalized daily jokes for all eligible users.

    Run this task daily (e.g., 00:01 UTC) via Celery Beat schedule.
    Creates DailyJoke records for users who have completed onboarding.

    Returns dict with generation stats for monitoring.
    """
    User = get_user_model()
    today = timezone.now().date()

    stats = {
        'date': str(today),
        'processed': 0,
        'created': 0,
        'skipped_existing': 0,
        'skipped_no_joke': 0,
    }

    # Only generate for users who completed onboarding
    eligible_users = User.objects.filter(
        preference__onboarding_completed=True
    ).select_related('preference')

    for user in eligible_users:
        stats['processed'] += 1

        # Skip if already has today's joke
        if DailyJoke.objects.filter(user=user, date=today).exists():
            stats['skipped_existing'] += 1
            continue

        # Get recently shown jokes (30-day window)
        exclude_ids = get_recently_shown_joke_ids(user, days=30)

        # Get personalized joke
        joke = get_personalized_joke(user, exclude_joke_ids=exclude_ids)

        if joke:
            DailyJoke.objects.create(
                user=user,
                joke=joke,
                date=today
            )
            stats['created'] += 1
        else:
            # No joke available (dataset exhausted)
            stats['skipped_no_joke'] += 1

    return stats


@shared_task(name='jokes.generate_daily_joke_for_user')
def generate_daily_joke_for_user(user_id):
    """
    Generate daily joke for a specific user.
    Used for on-demand generation when user first accesses daily joke.

    Returns joke_id if created, None if already exists or no joke available.
    """
    User = get_user_model()
    today = timezone.now().date()

    try:
        user = User.objects.select_related('preference').get(id=user_id)
    except User.DoesNotExist:
        return None

    # Skip if already has today's joke
    existing = DailyJoke.objects.filter(user=user, date=today).first()
    if existing:
        return existing.joke_id

    # Get recently shown jokes (30-day window)
    exclude_ids = get_recently_shown_joke_ids(user, days=30)

    # Get personalized joke
    joke = get_personalized_joke(user, exclude_joke_ids=exclude_ids)

    if joke:
        daily = DailyJoke.objects.create(
            user=user,
            joke=joke,
            date=today
        )
        return daily.joke_id

    return None
```

Key design decisions:
- generate_daily_jokes() is for batch processing (Celery Beat schedule)
- generate_daily_joke_for_user() is for on-demand fallback
- Both use 30-day recency window from recommendations.py
- Return stats dict for monitoring/debugging
  </action>
  <verify>python -c "from jokes.tasks import generate_daily_jokes, generate_daily_joke_for_user; print('OK')" succeeds</verify>
  <done>tasks.py created with generate_daily_jokes and generate_daily_joke_for_user tasks</done>
</task>

<task type="auto">
  <name>Task 2: Create Daily Joke API endpoint</name>
  <files>jokes/views.py, jokes/serializers.py, jokes/urls.py</files>
  <action>
Add DailyJokeSerializer to jokes/serializers.py:

```python
class DailyJokeSerializer(serializers.ModelSerializer):
    joke = JokeSerializer(read_only=True)

    class Meta:
        model = DailyJoke
        fields = ['id', 'joke', 'date', 'delivered_at', 'created_at']
        read_only_fields = ['id', 'joke', 'date', 'delivered_at', 'created_at']
```

Add DailyJokeViewSet to jokes/views.py:

```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone

from .models import DailyJoke
from .serializers import DailyJokeSerializer, JokeSerializer
from .recommendations import get_personalized_joke, get_recently_shown_joke_ids


class DailyJokeViewSet(viewsets.GenericViewSet):
    """
    ViewSet for daily joke functionality.
    All endpoints require authentication.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = DailyJokeSerializer

    def get_queryset(self):
        return DailyJoke.objects.filter(user=self.request.user)

    @action(detail=False, methods=['get'])
    def today(self, request):
        """
        Get today's personalized joke.

        If scheduled task already generated one, return it.
        Otherwise, generate on-demand (fallback).

        Returns 404 if no joke available (dataset exhausted).
        """
        today = timezone.now().date()

        # Try to get pre-generated daily joke
        daily = DailyJoke.objects.filter(
            user=request.user,
            date=today
        ).select_related(
            'joke',
            'joke__format',
            'joke__age_rating',
            'joke__language'
        ).prefetch_related(
            'joke__tones',
            'joke__context_tags'
        ).first()

        if not daily:
            # Fallback: generate on-demand
            exclude_ids = get_recently_shown_joke_ids(request.user, days=30)
            joke = get_personalized_joke(request.user, exclude_joke_ids=exclude_ids)

            if joke:
                daily = DailyJoke.objects.create(
                    user=request.user,
                    joke=joke,
                    date=today
                )
            else:
                return Response(
                    {'detail': 'No jokes available. Please try again later.'},
                    status=status.HTTP_404_NOT_FOUND
                )

        # Mark as delivered on first access
        if not daily.delivered_at:
            daily.delivered_at = timezone.now()
            daily.save(update_fields=['delivered_at'])

        return Response(DailyJokeSerializer(daily).data)

    @action(detail=False, methods=['get'])
    def history(self, request):
        """
        Get user's daily joke history.
        Returns last 30 days of daily jokes.
        """
        queryset = self.get_queryset().select_related(
            'joke',
            'joke__format',
            'joke__age_rating',
            'joke__language'
        ).prefetch_related(
            'joke__tones',
            'joke__context_tags'
        )[:30]

        serializer = DailyJokeSerializer(queryset, many=True)
        return Response(serializer.data)
```

Register in jokes/urls.py:

```python
from .views import DailyJokeViewSet

router.register(r'daily-jokes', DailyJokeViewSet, basename='daily-jokes')
```

This provides:
- GET /api/v1/daily-jokes/today/ - Get today's joke
- GET /api/v1/daily-jokes/history/ - Get last 30 days of jokes
  </action>
  <verify>python manage.py check passes, curl commands work against dev server</verify>
  <done>DailyJokeViewSet with today() and history() actions, registered at /api/v1/daily-jokes/</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python manage.py check` passes with no errors
- [ ] `python -c "from jokes.tasks import generate_daily_jokes; print('OK')"` succeeds
- [ ] `python -c "from jokes.views import DailyJokeViewSet; print('OK')"` succeeds
- [ ] API endpoint `/api/v1/daily-jokes/today/` returns 401 for unauthenticated requests
- [ ] All Phase 9 success criteria met (models, tasks, API)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Celery task ready for scheduling via django-celery-beat admin
- API endpoint ready for frontend integration
- Phase 09: Daily Joke complete
</success_criteria>

<output>
After completion, create `.planning/phases/09-daily-joke/09-03-SUMMARY.md`

Update `.planning/STATE.md`:
- Mark Phase 09 as complete
- Add decisions: "Content-based filtering for MVP (defer collaborative filtering)"
- Update next actions to Phase 10: Sharing
</output>
